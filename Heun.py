import numpy as np
from Utilities import dot, cross

# Constants
gamma = 0.1760859644
muB = 5.7883818012e-2

def EffField(spins, J, nbl, K, Z, DD, pos, muS, DMI):
    Ddip = 0.9274009994 * muS
    H = np.zeros_like(spins)
    for i in range(spins.shape[0]):
        wx, wy, wz = 0.0, 0.0, 0.0
        
        # Exchange
        for j in range(len(nbl[i])):
            wx += 2 * J * spins[nbl[i][j]][0] / (muB * muS)
            wy += 2 * J * spins[nbl[i][j]][1] / (muB * muS)
            wz += 2 * J * spins[nbl[i][j]][2] / (muB * muS)
        # Zeeman
        wx += Z[0]
        wy += Z[1]
        wz += Z[2]
        
        # Dipole
        if DD == True:
            for j in range(spins.shape[0]):
                if j != i:
                    lenr = np.linalg.norm(pos[i] - pos[j])
                    rij = (pos[i] - pos[j]) / lenr
                    EffField = (Ddip / lenr**3) * (3 * dot(spins[j], rij) * 
                                                   rij - spins[j])
                    wx += EffField[0]
                    wy += EffField[1]
                    wz += EffField[2]
        
        # Dzyaloshinskii-Moriya
        for j in range(len(nbl[i])):
            DM = (np.cross(spins[nbl[i][j]], DMI[i][nbl[i][j]]) + 
                  np.cross(DMI[nbl[i][j]][i], spins[nbl[i][j]])) / (muS * muB)
            wx += DM[0]
            wy += DM[1]
            wz += DM[2]
        
        # Anisotropy
        wz += 2 * (K[i] / (muB * muS)) * spins[i][2]
        
        H[i][0] = wx
        H[i][1] = wy
        H[i][2] = wz
    return H

def LLG(spin, H, eta):
    s = -(gamma / (1+eta**2)) * (cross(spin, H) + eta * cross(spin, cross(spin, H)))
    return s

def Heun(spins, J, nbl, K, Z, DD, pos, muS, dt, eta, DMI):
    H = EffField(spins, J, nbl, K, Z, DD, pos, muS, DMI)
    sp = np.zeros_like(spins)
    sp2 = np.zeros_like(spins)
    for k in range(spins.shape[0]):
        sp[k] = spins[k] + dt * LLG(spins[k], H[k], eta)
    H2 = EffField(sp, J, nbl, K, Z, DD, pos, muS, DMI)
    for k in range(spins.shape[0]):
        sp2[k] = spins[k] + (dt / 2) * (LLG(spins[k], H[k], eta) + LLG(sp[k], H2[k], eta))
    return sp2

def main():
    from BuildNbl import Constructnbl
    import matplotlib.pyplot as plt
    from CalcEnergy import energies
    from time import time
    
# =============================================================================
#     sz = (1, 1, 1)
#     spins = np.array([[1.0, 0.0, 0.0]])
#     pos = np.array([[0.0, 0.0, 0.0]])
# =============================================================================
    
# =============================================================================
#     sz = (1, 1, 2)
#     spins = np.array([[0.1, -0.1, 0.989949366], [0.4, 0.2, 0.894427191]])
#     pos = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]])
# =============================================================================
    
    sz = (1, 1, 50)
    spins = np.array([[0.1, -0.1, 0.989949366], 
                   [0.4, 0.2, 0.894427191],
                   [1.0, 0.0, 0.0],
                   [0.4, -0.2, 0.894427191],
                   [0.0, 0.0, 1.0],
                   [-0.4, 0.2, 0.894427191],
                   [0.1, -0.1, -0.989949366],
                   [0.0, -1.0, 0.0],
                   [-0.1, 0.1, 0.989949366],
                   [-0.4, 0.2, -0.894427191],
                   [0.1, -0.1, 0.989949366], 
                   [0.4, 0.2, 0.894427191],
                   [1.0, 0.0, 0.0],
                   [0.4, -0.2, 0.894427191],
                   [0.0, 0.0, 1.0],
                   [-0.4, 0.2, 0.894427191],
                   [0.1, -0.1, -0.989949366],
                   [0.0, -1.0, 0.0],
                   [-0.1, 0.1, 0.989949366],
                   [-0.4, 0.2, -0.894427191],
                   [0.1, -0.1, 0.989949366], 
                   [0.4, 0.2, 0.894427191],
                   [1.0, 0.0, 0.0],
                   [0.4, -0.2, 0.894427191],
                   [0.0, 0.0, 1.0],
                   [-0.4, 0.2, 0.894427191],
                   [0.1, -0.1, -0.989949366],
                   [0.0, -1.0, 0.0],
                   [-0.1, 0.1, 0.989949366],
                   [-0.4, 0.2, -0.894427191],
                   [0.1, -0.1, 0.989949366], 
                   [0.4, 0.2, 0.894427191],
                   [1.0, 0.0, 0.0],
                   [0.4, -0.2, 0.894427191],
                   [0.0, 0.0, 1.0],
                   [-0.4, 0.2, 0.894427191],
                   [0.1, -0.1, -0.989949366],
                   [0.0, -1.0, 0.0],
                   [-0.1, 0.1, 0.989949366],
                   [-0.4, 0.2, -0.894427191],
                   [0.1, -0.1, 0.989949366], 
                   [0.4, 0.2, 0.894427191],
                   [1.0, 0.0, 0.0],
                   [0.4, -0.2, 0.894427191],
                   [0.0, 0.0, 1.0],
                   [-0.4, 0.2, 0.894427191],
                   [0.1, -0.1, -0.989949366],
                   [0.0, -1.0, 0.0],
                   [-0.1, 0.1, 0.989949366],
                   [-0.4, 0.2, -0.894427191],])
    pos = np.array([[0.0, 0.0, 0.0], 
                    [0.0, 0.0, 1.0],
                    [0.0, 0.0, 2.0],
                    [0.0, 0.0, 3.0],
                    [0.0, 0.0, 4.0],
                    [0.0, 0.0, 5.0],
                    [0.0, 0.0, 6.0],
                    [0.0, 0.0, 7.0],
                    [0.0, 0.0, 8.0],
                    [0.0, 0.0, 9.0],
                    [0.0, 0.0, 10.0], 
                    [0.0, 0.0, 11.0],
                    [0.0, 0.0, 12.0],
                    [0.0, 0.0, 13.0],
                    [0.0, 0.0, 14.0],
                    [0.0, 0.0, 15.0],
                    [0.0, 0.0, 16.0],
                    [0.0, 0.0, 17.0],
                    [0.0, 0.0, 18.0],
                    [0.0, 0.0, 19.0],
                    [0.0, 0.0, 20.0], 
                    [0.0, 0.0, 21.0],
                    [0.0, 0.0, 22.0],
                    [0.0, 0.0, 23.0],
                    [0.0, 0.0, 24.0],
                    [0.0, 0.0, 25.0],
                    [0.0, 0.0, 26.0],
                    [0.0, 0.0, 27.0],
                    [0.0, 0.0, 28.0],
                    [0.0, 0.0, 29.0],
                    [0.0, 0.0, 30.0], 
                    [0.0, 0.0, 31.0],
                    [0.0, 0.0, 32.0],
                    [0.0, 0.0, 33.0],
                    [0.0, 0.0, 34.0],
                    [0.0, 0.0, 35.0],
                    [0.0, 0.0, 36.0],
                    [0.0, 0.0, 37.0],
                    [0.0, 0.0, 38.0],
                    [0.0, 0.0, 39.0],
                    [0.0, 0.0, 40.0], 
                    [0.0, 0.0, 41.0],
                    [0.0, 0.0, 42.0],
                    [0.0, 0.0, 43.0],
                    [0.0, 0.0, 44.0],
                    [0.0, 0.0, 45.0],
                    [0.0, 0.0, 46.0],
                    [0.0, 0.0, 47.0],
                    [0.0, 0.0, 48.0],
                    [0.0, 0.0, 49.0],])
    
    n_s = sz[0] * sz[1] * sz[2]
    nbl = Constructnbl(sz, pbc = [False, False, False])
    
    
# =============================================================================
#     spins = np.array([[1.0, 0.0, 0.0]])
#     pos = np.array([[0.0, 0.0, 0.0]])
# =============================================================================
    
    J = 1.0
    K = np.ones(n_s) * 1.0
    DD = False
    Z = np.array([0.0, 0.0, 0.5])
    DMI = np.zeros(shape = (n_s,n_s,3))
# =============================================================================
#     DMI[0][1] = np.array([1.0, 1.0, 1.0])
#     DMI[1][0] = np.array([-1.0, -1.0, -1.0])
# =============================================================================
    muS = 1.0
    eta = 0.1
    
    dt = 0.001
    n = 60000
    
# =============================================================================
#     En = np.zeros(n+1)
#     E = energies(spins, nbl, J, K, Z, DD, pos, DMI, muS)
#     En[0] = E / (sz[0] * sz[1] * sz[2])
# =============================================================================
    
# =============================================================================
#     magF1 = np.zeros(shape = (n+1,3))
#     magF1[0] = spins[0]
# =============================================================================
# =============================================================================
#     magF2 = np.zeros(shape = (n+1,3))
#     magF2[0] = spins[1]
# =============================================================================
    
    # Forward propagation
    start = time()
    for j in range(n):
        spins = Heun(spins, J, nbl, K, Z, DD, pos, muS, dt, eta, DMI)
#        magF1[j+1] = spins[0]
#        magF2[j+1] = spins[1]
# =============================================================================
#         E = energies(spins, nbl, J, K, Z, DD, pos, DMI, muS)
#         En[j+1] = E / (sz[0] * sz[1] * sz[2])   
# =============================================================================
    end = time()
    el = end - start
    print(f"Elapsed time Heun Damped 50 spins: {el}")
# =============================================================================
#     dt = -dt
# # =============================================================================
# #     En2 = np.zeros(n+1)
# #     E = energies(spins, nbl, J, K, Z, DD, pos, DMI, muS)
# #     En2[-1] = E / (sz[0] * sz[1] * sz[2])
# # =============================================================================
# 
#     magB1 = np.zeros(shape = (n+1,3))
#     magB1[-1] = spins[0]
#     magB2 = np.zeros(shape = (n+1,3))
#     magB2[-1] = spins[1]
#     
#     # Backwards propagation
#     for j in range(n):
#         spins = Heun(spins, J, nbl, K, Z, DD, pos, muS, dt, eta, DMI)
#         magB1[n-1-j] = spins[0]
#         magB2[n-1-j] = spins[1]
# # =============================================================================
# #         E = energies(spins, nbl, J, K, Z, DD, pos, DMI, muS)
# #         En2[n-1-j] = E / (sz[0] * sz[1] * sz[2])
# # =============================================================================
# 
#     mag1 = magF1 - magB1
#     mag2 = magF2 - magB2
#     magF = np.concatenate((magF1, magF2), axis = 1)
#     magB = np.concatenate((magB1, magB2), axis = 1)
#   #  EnFB = np.column_stack((En, En2))
#     
#     mg = np.concatenate((mag1, mag2), axis = 1)
#   #  EnDiff = En - En2
#     np.savetxt(r"ComparisonTests/ComponentDiffHeun_DissCorr.txt", mg)
# =============================================================================
  #  np.savetxt(r"ComparisonTests/EnergyDiffHeun_Diss.txt", EnDiff)
  #  np.savetxt(r"ComparisonTests/TimestepHeun_1.txt", magF1)
  #  np.savetxt(r"ComparisonTests/ComponentsHeunBack_CorrectedOneSpin1.txt", magB1)
  #  np.savetxt(r"ComparisonTests/EnergyHeun_Diss.txt", EnFB)
    
# =============================================================================
#     np.save("HeunTrajDissForw", magF1[::100])
#     np.save("HeunTrajDissBack", magB1[::100])
# =============================================================================
        
#    t = np.linspace(0, np.abs(dt) * n, n+1)
# =============================================================================
#     plt.plot(t, magF[:,0])
#     plt.plot(t, magF[:,1])
#     plt.plot(t, magF[:,2])
#     plt.scatter(t[::200], magB[::200, 0])
#     plt.scatter(t[::200], magB[::200, 1])
#     plt.scatter(t[::200], magB[::200, 2])
# =============================================================================
# =============================================================================
#     np.save("HeunEnergyExAnForw", En)
#     np.save("HeunEnergyExAnBack", En2)
# =============================================================================
# =============================================================================
#     plt.plot(t, En)
#     plt.plot(t, En2)
# =============================================================================
    #print(spins)

if __name__=="__main__":
    main()